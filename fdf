[1mdiff --git a/game.py b/game.py[m
[1mindex 0e41f81..b02585a 100644[m
[1m--- a/game.py[m
[1m+++ b/game.py[m
[36m@@ -114,7 +114,6 @@[m [mclass Game:[m
                     self.board[x_1][y_1]['occupant'] == 'O'):[m
                 self.board[x_0][y_0]['occupant'] = color[m
                 self.board[x_1][y_1]['occupant'] = color[m
[31m-                self.turn += 2[m
                 chose_spaces = True[m
 [m
     def get_minimax_score(self, color):[m
[36m@@ -164,7 +163,7 @@[m [mclass Game:[m
         # being far apart[m
         # todo: have distance score change based on self.turn of turns[m
         if self.turn < 20:[m
[31m-            score += self.get_distance_score(self.color, other_color) / ( self.turn / 4)[m
[32m+[m[32m            score += self.get_distance_score(self.color, other_color) / (self.turn)[m
 [m
         return score[m
 [m
[36m@@ -322,7 +321,7 @@[m [mclass Game:[m
             self.message = "Occupied Space"[m
         else:[m
             self.board[x_val][y_val]['occupant'] = color[m
[31m-            self.turn += 1[m
[32m+[m[32m            #self.turn += 1[m
             return True[m
         return False[m
 [m
[36m@@ -448,8 +447,6 @@[m [mclass Game:[m
         tree_depth : int[m
             Depth of the tree. How far to look ahead for creating potential moves[m
         """[m
[31m-        # self.color = move_color[m
[31m-        # self.check_move_available()[m
         if self.end:[m
             return[m
 [m
[36m@@ -489,7 +486,6 @@[m [mclass Game:[m
         self.board = best_node.game.board[m
         self.end = best_node.game.end[m
 [m
[31m-        #self.check_move_available()[m
         if not self.end:[m
             self.sub_turn = 'switch'[m
 [m
[36m@@ -556,6 +552,7 @@[m [mclass Game:[m
         new_game.col = game.col[m
         new_game.row = game.row[m
         new_game.color = color[m
[32m+[m[32m        new_game.turn = game.turn[m
 [m
         return new_game[m
 [m
